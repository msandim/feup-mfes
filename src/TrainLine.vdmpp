class TrainLine
types
	public String = seq of char; 
values

instance variables
	private modules: seq of Module := [];
	private trains: seq of Train := [];
	
	private headModule: [Module] := nil;
	private tailModule: [Module] := nil;
	
	-- Colocar invariante de headModule e tailModule serem ambos nulos antes de se adicionar modulos
	
operations
	
	-- *****************************************************************
	-- **************************** Constructors ************************
	-- *****************************************************************	
	
	-- *****************************************************************
	-- ************************ Public Methods *************************
	-- *****************************************************************
	
	-- ** Adds a simple module (between 2 stations) to the line: **
	public addSimpleModule: (String) ==> ()
	addSimpleModule(id) ==
	(
		dcl simpleModule: Module := new SimpleModule(id, self);
		addModule(simpleModule);
	);
	
	-- Adds a station module to the line:
	public addStationModule: (String) ==> ()
	addStationModule(id) ==
	(
		dcl stationModule: Module := new StationModule(id, self);
		return addModule(stationModule);
	);
	
	-- Closes the circular track:
  public closeCircularTrack: () ==> ()
	closeCircularTrack() ==
	(
		headModule.setDownModule(tailModule);
		tailModule.setUpModule(headModule);
	)
	pre len modules >= 2 -- To close a circular track we have to have at least two modules in the track
	post headModule.getDownModule() = tailModule and -- the first module must be linked to the last model
		tailModule.getUpModule() = headModule; -- The last module must be linked to the first model
	
	-- Adds a train to the train line:
	public addTrain: (String) * (Train`Orientation) * nat1 ==> ()
	addTrain(id, orientation, moduleId) ==
	(
		trains := trains ^ [new Train(id, orientation, modules(moduleId).getBlock(orientation))];
	);
	/**
	pre moduleId in set dom modules and -- The module we want the train on must be valid
		not exists t1 in set rng trains & t1.getBlock().getModule() = modules(moduleId) and -- The module must not have any train on
		id not in set dom trains -- An id with this train must not exist
	post id in set dom trains and -- The id was added to the modules
		exists1 t1 in set rng trains & t1.getBlock().getModule() = modules(moduleId); -- The train is now in this module
		*/
	
	-- Moves a train with a specific id
	public moveTrain: (nat1) ==> ()
	moveTrain(id) ==
	(
		trains(id).move();
	);
	
	-- *****************************************************************
	-- ****************** Private Auxiliar Methods *********************
	-- *****************************************************************
	
	-- Adds a module to the station
	private addModule: (Module) ==> ()
	addModule(newModule) ==
	(
		if len modules > 0 -- if we already have a module added
		then
		(			
			IO`println("Tenho mais do que um modulo e vou inserir mais um");
			
			-- Connect the new model to the last model insered:
			tailModule.setUpModule(newModule);
			newModule.setDownModule(tailModule);
			
			-- Update the last model inserted:
			tailModule := newModule;
			
			IO`println("acabei a atribuicao");
		)
		else
		(
			IO`println("Novo modulo e n tinha nenhum");
			headModule := newModule;
			tailModule := newModule;
		);
		
		IO`println("vou fazer a union");
		modules := modules ^ [newModule];
		IO`println("acabei a union");
		
		IO`print("novo size:"); IO`println(len modules);		
	);
	--pre newModule not in set modules -- the id we're adding is completely new
	--post newModule in set modules and -- The id was added to the modules
	  --if card modules~ = 0
	  	--then (headModule = newModule and tailModule = newModule)
	    --else (tailModule = newModule);
		
	public pure getTrain: nat1 ==> Train
	getTrain(id) == return trains(id);
	
	public pure getModule: nat1 ==> Module
	getModule(id) == return modules(id);
	
	-- Gets
	/*
	pure public getTrains: () ==> (map String to Train)
	getTrains() == 
	(
		return trains;
	); */

functions

traces

end TrainLine