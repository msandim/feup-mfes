class Train
types
	public Orientation = <Up> | <Down>;
	public MovementStatus = <Stopped> | <Moving>;
values

instance variables
	private id: TrainLine`String;
	
	private orientation: Orientation := <Up>;
	private status: MovementStatus := <Stopped>;
	private currentBlock: Block;
	
operations

	-- Constructor
	public Train: (Orientation) * (Block) ==> Train
	Train(initialOrientation, initialBlock) ==
	(
		orientation := initialOrientation;
		currentBlock := initialBlock;
		return self;
	);
	
	-- Move a train
	public move: () ==> ()
	move() ==
	(
		-- Update status:
		status := <Moving>;
		
		-- Make exit operations on the block we were on:
		currentBlock.trainExit(orientation);
	
		-- Make enter operations on the block we're going on:
		currentBlock.getNextBlock(orientation).trainEnter(orientation);
			
		-- Move to the next block:	
		currentBlock := currentBlock.getNextBlock(orientation);
	)
	pre currentBlock.getNextBlock(orientation).canEnter(orientation)
	post currentBlock = currentBlock~.getNextBlock(orientation) and -- New block is equal to old block's next block
		not currentBlock.canEnter(orientation) and -- We cannot enter in the new block (New block is red)
	  (if currentBlock.getPreviousBlock(orientation).getPreviousBlock(orientation).isInStation() then -- Check if sempahore from the block we're exiting is ok
	  		currentBlock.getPreviousBlock(orientation).getSemaphore(orientation).getColor() = <Red>
	  	else
	  		currentBlock.getPreviousBlock(orientation).getSemaphore(orientation).getColor() = <Yellow>
	  ) and
	  (if currentBlock.getPreviousBlock(orientation).getPreviousBlock(orientation).getPreviousBlock(orientation).isInStation() 
	  			or currentBlock.getPreviousBlock(orientation).getPreviousBlock(orientation).getSemaphore(orientation).getSensor() = <Busy> then -- We should put red if its a block next to a station, or a train is there
	  		currentBlock.getPreviousBlock(orientation).getPreviousBlock(orientation).getSemaphore(orientation).getColor() = <Red>
	  	elseif currentBlock.getPreviousBlock(orientation).getPreviousBlock(orientation).isInStation() then
	  		currentBlock.getPreviousBlock(orientation).getPreviousBlock(orientation).getSemaphore(orientation).getColor() = <Yellow>
	  	else
	  		currentBlock.getPreviousBlock(orientation).getPreviousBlock(orientation).getSemaphore(orientation).getColor() = <Green>
	  );
	  
	public stopAction: () ==> ()
	stopAction() == status := <Stopped>
	pre status = <Moving>;
	
		
	public requestLeaveStation: () ==> bool
	requestLeaveStation() ==
	(
		-- See if we can exit ==> the set of blocks until the next station must be cleared:
		if isPathClearedUntilNextStation()
		then
		(	
			currentBlock.getNextBlock(orientation).setSemaphore(<Green>, orientation);
			return true;
		)
		else
			return false;
	)
	pre status = <Stopped> and currentBlock.isInStation() and currentBlock.getNextBlock(orientation).getSemaphore(orientation).getColor() = <Red>
	post if isPathClearedUntilNextStation() then currentBlock.getNextBlock(orientation).getSemaphore(orientation).getColor() = <Green>
		else currentBlock.getNextBlock(orientation).getSemaphore(orientation).getColor() = <Red>;
	
	-- Gets
	pure public getCurrentBlock: () ==> Block
	getCurrentBlock() == return currentBlock;
	
	pure public getNextBlock: () ==> Block
	getNextBlock() == return currentBlock.getNextBlock(orientation);
	
	pure public getPreviousBlock: () ==> Block
	getPreviousBlock() == return currentBlock.getPreviousBlock(orientation);
	
	pure public getOrientation: () ==> Orientation
	getOrientation() == return orientation;
	
	pure public getIsStopped: () ==> bool
	getIsStopped() == return status = <Stopped>;
	
	pure public getId: () ==> TrainLine`String
	getId() == return id;
	
	-- Private methods:
	private pure isPathClearedUntilNextStation: () ==> bool
	isPathClearedUntilNextStation() ==
	(
		dcl nextBlock: Block := currentBlock.getNextBlock(orientation);
		
		-- Iterate the next blocks and check if we can make it to the next station without being stuck somewhere in between:
		while (not nextBlock.getModule().getIsStation())
			and nextBlock.getSemaphore(orientation).getSensor() = <Free> and nextBlock.getSemaphore(orientation).isSensorAvailable()
			and nextBlock.getSemaphore(oppositeOrientation()).getSensor() = <Free> and nextBlock.getSemaphore(oppositeOrientation()).isSensorAvailable() do
				nextBlock := nextBlock.getNextBlock(orientation);
		
		-- If we got to the next station in the previous cycle, then the path is clear, but we have to check if it's busy
		-- But in the station, we only want to check if the semaphore for our orientaton is on
		return (nextBlock.getModule().getIsStation() and nextBlock.getSemaphore(orientation).getSensor() = <Free> and nextBlock.getSemaphore(orientation).isSensorAvailable());
	)
	pre status = <Stopped> and currentBlock.isInStation(); -- We can only execute this function when we're stopped in a station
	
	public pure oppositeOrientation: () ==> (Orientation)
	oppositeOrientation() == 
	(
		if orientation = <Up>
		then return <Down>
		else return <Up>;
	);

functions

traces

end Train