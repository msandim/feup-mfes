class Block

types
	public Semaphore = <Red> | <Yellow> | <Green> | <Unavailable>;
	public Sensor = <Free> | <Busy> | <Unavailable>;
		
instance variables
	private module : Module;
	private trainLine: TrainLine;
	
	private sensor: Sensor := <Free>;
	private upSemaphore: Semaphore := <Green>;
	private downSemaphore: Semaphore := <Green>;
	private true_self: Block;
	
	-- Invariants:
	--inv (sensor = <Free> and upSemaphore <> <Red> and downSemaphore <> <Red>) or (sensor = <Busy> and 
	
	-- Sensor must be unavailable or mark if a train is in the block
	/** inv (sensor = <Free> and
			not exists t in set rng trainLine.getTrains() & t.getCurrentBlock() = true_self)
		or (sensor = <Busy> and
			exists1 t in set rng trainLine.getTrains() & t.getCurrentBlock() = true_self)
		or sensor = <Unavailable>; */
	
	-- Semaphore must be unavailable or mark if a train is in the block
	/*inv ((semaphore = <Green> or semaphore = <Yellow>) and
			not exists t in set (rng trainLine.getTrains()) & t.getCurrentBlock() = true_self)
		or (semaphore = <Red> and
			exists1 t in set (rng trainLine.getTrains()) & t.getCurrentBlock() = true_self)
		or semaphore = <Unavailable>;*/
	
operations

	-- Constructor
	public Block: (Module) * (TrainLine) ==> Block
	Block(moduleArg, trainLineArg) ==
	(
		module := moduleArg;
		trainLine := trainLineArg;
		true_self := self;
		
		return self
	);
	
	public trainEnter: (Train`Orientation) ==> ()
	trainEnter(trainOrientation) ==
	(
		if trainOrientation = <Up>
		then atomic
		(
			upSemaphore := <Red>;
			sensor := <Busy>;
		)
		else atomic
		(
			downSemaphore := <Red>;
			sensor := <Busy>;
		);	
	);
	
	public trainExit: (Train`Orientation) ==> ()
	trainExit(trainOrientation) ==
	(
		-- Update the block we're leaving
		dcl semaphoreNextState: Semaphore;
		dcl previousSemaphoreNextState: Semaphore;
		
		-- If this is a module after a station, it must be red at all time, otherwise yellow
		if getModule().getPreviousModule(trainOrientation).getIsStation()
		then
			semaphoreNextState := <Red>
		else
			semaphoreNextState := <Yellow>;
	
		if trainOrientation = <Up>
		then atomic
		(
			upSemaphore := semaphoreNextState
			sensor := <Free>;
		)
		else atomic
		(
			downSemaphore := semaphoreNextState
			sensor := <Free>;
		);
		
		-- Check the previous block to the block we're leaving:
		-- If the previous block from the block we're leaving is a station, leave it yellow
		if (getModule().getPreviousModule(trainOrientation).getIsStation()) then
			previousSemaphoreNextState := <Yellow>
		elseif (getModule().getPreviousModule(trainOrientation).getPreviousModule(trainOrientation).getIsStation()) then -- If the previous-previous block is a station, then it must be red
			previousSemaphoreNextState := <Red>
		else
			previousSemaphoreNextState := <Green>;
			
		getModule().getPreviousModule(trainOrientation).getBlock(trainOrientation).setSemaphore(previousSemaphoreNextState, trainOrientation);
	);
	
	-- Methods
	pure public canEnter: (Train`Orientation) ==> (bool)
	canEnter(orientationArg) ==
	(
		if orientationArg = <Up>
		then
			return upSemaphore <> <Red>
		else
			return downSemaphore <> <Red>;
	);
	
	pure public canEnterNextBlock: (Train`Orientation) ==> (bool)
	canEnterNextBlock(orientation) ==
	(
		return getNextBlock(orientation).canEnter(orientation);
	);
	
	pure public isInStation: () ==> (bool)
	isInStation() ==
	(
		return module.getIsStation();
	);
	
	-- Gets
	pure public getSemaphore: (Train`Orientation) ==> (Semaphore)
	getSemaphore(orientationArg) == 
	(
		if orientationArg = <Up>
		then
			return upSemaphore
		else
			return downSemaphore;
	);
	
	pure public getSensor: () ==> (Sensor)
	getSensor() == return sensor;
	
	pure public getModule: () ==> (Module)
	getModule() ==
	(
		return module;
	);
	
	pure public getNextBlock: (Train`Orientation) ==> (Block)
	getNextBlock(orientation) == 
	(
		return module.getNextBlock(orientation);
	);
	
	pure public getPreviousBlock: (Train`Orientation) ==> (Block)
	getPreviousBlock(orientation) == 
	(
		return module.getPreviousBlock(orientation);
	);
	
	-- Sets
	public setSemaphore: (Semaphore) * (Train`Orientation) ==> ()
	setSemaphore(semaphoreArg, orientationArg) ==
	(	
		if orientationArg = <Up>
		then
			upSemaphore := semaphoreArg
		else
			downSemaphore := semaphoreArg;
	);

end Block